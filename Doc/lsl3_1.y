/* 
**  Grammar for LSL3.1
**  
**  FIX:
**    Redefine openSym, closeSym to include [, ]
**    Handle ambiguities wrt sort a[b] generated by
**    Fix term syntax to match LP
*/

%{
/* C declarations */
%}

/* yacc declarations */

%token closeSym, eqSepSym, equationSym, mapSym, markerSym, openSym
%token quantifierSym, quantifierSym1, selectSym, sepSym
%token simpleId, eqOp, logicalOp, simpleOp
%token ASSERTS, ASSUMES, BY, CONVERTS, ELSE, ENUMERATION, EOF, EQUATIONS
%token EXEMPTING, FREELY, IMPLIES, INCLUDES, FOR, GENERATED, IF, INTRODUCES, OF
%token PARTITIONED, SORT, THEN, TRAIT, TUPLE, UNION


%% /* Grammar rules */



trait:		  traitId                 ':' TRAIT traitBody EOF
    		| traitId '(' formals ')' ':' TRAIT traitBody EOF
 
formals:	  formal
    		| formals ',' formal
;
 
formal:		  name ':' signature
  		| opForm
    		| compoundSort
		| sortOrOpId
;
 
name:		  opId
    		| opForm
;
 
opForm:    	  IF markerSym THEN markerSym ELSE markerSym
		|           anyOp
    		| markerSym anyOp
		|           anyOp markerSym
    		| markerSym anyOp markerSym
		|           openSymbol middle closeSymbol
    		| markerSym openSymbol middle closeSymbol
		|           openSymbol middle closeSymbol markerSym
    		| markerSym openSymbol middle closeSymbol markerSym
		|           selectSym simpleId
    		| markerSym selectSym simpleId
;
 
anyOp:		  simpleOp
    		| logicalOp
    		| eqOp
;
 
openSymbol:	  openSym
  		| '['
;

closeSymbol:	  closeSym
  		| ']'
;

middle:		  /* EMPTY */
		| places
;
 
places:		  markerSym
    		| places separator markerSym
;

separator:	  sepSym
    		| ','
;
 
signature:	  domain mapSym range
 
domain:		  /* EMPTY */
		| sorts
;
 
sorts:	          sort
    		| sorts ',' sort
;
 
range:		  sort
;
 
sort:		  sortId
		| compoundSort
;

compoundSort:	  sortId '[' sorts ']'
;
 
traitBody:                      simpleTrait
    		|               simpleTrait consequences
    		| traitContexts simpleTrait
    		| traitContexts simpleTrait consequences
;
 
traitContexts:    traitContext
    		| traitContexts traitContext
;
 
traitContext:     shorthand
    		| external
;
 
shorthand:	  enumeration
    		| tuple
    		| union
;
 
enumeration:	  sort ENUMERATION OF elementIds
;
 
elementIds:       elementId
    		| elementIds ',' elementId
;
 
tuple:		  sort TUPLE OF fieldList
;
 
union:		  sort UNION OF fieldList
;
 
fieldList:	  fields
    		| fieldList ',' fields
;
 
fields:		  fieldIds ':' sort
;
 
fieldIds:   	  fieldId
    		| fieldIds ',' fieldId
;
 
external:	  INCLUDES traitRefs
    		| ASSUMES  traitRefs
;
 
traitRefs:        traitRef
    		| traitRefs ',' traitRef
;
 
traitRef:	  traitId
    		| traitId	   '(' renaming ')'
    		| '(' traitIds ')'
    		| '(' traitIds ')' '(' renaming ')'
;
 
traitIds:         traitId
    		| traitIds ',' traitId
;
 
renaming:		      replaces
    		| actuals
    		| actuals ',' replaces
;

actuals:	  actual
		| actuals ',' actual
;

actual:		  opForm
		| compoundSort
		| sortOrOpId
;

replaces:         replace
    		| replaces ',' replace
;
 
replace:    	  actual FOR formal
;
 
simpleTrait:	  opParts propParts
;
 
opParts:	  /* EMPTY */
		| opParts INTRODUCES opDcls
;
 
opDcls:           opDcl
    		| opDcls opDcl
;
 
opDcl:		  names ':' signature
;
 
names:            name
    		| names ',' name
;
 
propParts:	  /* EMPTY */
		| propParts ASSERTS props
;
 
props:			       eqPart
		| genPartProps eqPart
;
 
genPartProps:     genPartProp
    		| genPartProps genPartProp
;
 
genPartProp:      SORT sort GENERATED FREELY BY operators
		| SORT sort GENERATED BY operators
    		| SORT sort PARTITIONED BY operators
  		| sortId GENERATED FREELY BY operators
  		| sortId GENERATED BY operators
  		| sortId PARTITIONED BY operators
;
 
eqPart:                          quantifiedEqns
    		| EQUATIONS eqns quantifiedEqns
;
 
operators:        operator
    		| operators ',' operator
;
 
operator:    	  name
    		| name ':' signature
;
 
quantifiedEqns:   /* EMPTY */
		| quantifiedEqns quantifier eqns
;
 
eqns:             equation
    		| eqns eqSepSym equation
  		| eqns eqSepSym
;
 
quantifier:	  quantifierSym varDcl
    		| quantifier ','  varDcl
;
 
varDcl:		  varIds ':' sort
;
 
varIds:		  varId
    		| varIds ',' varId
;
 
equation:	  term
    		| term equationSym term
;
 
term:	    	  logicalTerm
    		| IF term THEN term ELSE term
;
 
logicalTerm:                            simpleOpTerm
    		| logicalTerm logicalOp simpleOpTerm
		| logicalTerm eqOp      simpleOpTerm
;
 
simpleOpTerm:	  prefixOpTerm
    		| secondary postfixOps
    		| secondary infixOpTerm
;
 
prefixOpTerm:	  secondary
    		| simpleOp prefixOpTerm
		| quantifiedVar prefixOpTerm
;

quantifiedVar:	  quantifierSym1 simpleId
		| quantifierSym1 simpleId ':' sort
;
 
postfixOps:	  simpleOp
    		| postfixOps simpleOp
;
 
infixOpTerm:
			      simpleOp secondary
    		| infixOpTerm simpleOp secondary
;
 
secondary:	  primary
   		|         bracketed
   		|         bracketed primary
    		| primary bracketed
    		| primary bracketed primary
;
 
bracketed:	  matched ':' sort
    		| matched
;
 
matched:	  openSymbol args closeSymbol
    		| openSymbol      closeSymbol
;
 
args:             term
    		| args separator term
;
 
primary:	  '(' term ')'
		| simpleId
    		| simpleId '(' terms ')'
    		| primary selectSym simpleId
    		| primary ':' sort
;
 
terms:		  term
		| terms ',' term
;
 
consequences:	  IMPLIES conseqProps conversions
;
 
conseqProps:    			 eqPart
		| traitRefs		 eqPart
                |           genPartProps eqPart
    		| traitRefs genPartProps eqPart
                |           genPartProps eqns
    		| traitRefs genPartProps eqns
;
 
conversions:	  /* EMPTY */
		| conversions conversion
;
 
conversion:	  CONVERTS operators
		| CONVERTS operators exemption
;
 
exemption:	  EXEMPTING            terms
		| EXEMPTING quantifier terms
;
 
traitId:	  simpleId
;
 
sortId:		  simpleId
;
 
varId:		  simpleId
;
 
fieldId:	  simpleId
;

elementId:	  simpleId
;
 
opId:		  simpleId
;

sortOrOpId:	  simpleId
;
