/*
**
**	Copyright (c) MIT, 1991
**	All Rights Reserved.  Unpublished rights reserved under the copyright 
**	laws of the United States.
**
**++
**  FACILITY:  LSL Checker
**
**  MODULE DESCRIPTION:
**
**      FILENAME:   prop.h
**
**	PURPOSE:    Interface to proposition abstraction
**
**	     A proposition is a discriminated union of equations, generatedBys,
**	partitionedBys, and traits.  Each proposition has a pedigree, which 
**	describes its ancestry in the main trait being checked.  For example,
**	given the trait hierarchy
**		     A
**		    / \
**		   B   C
**		      / \
**		     D   E
**		     |
**   		  assert nat generated by 0, s
**	the generatedBy proposition has the following depth-3 pedigree:
**	     A, C,   D		ancestral traits
**	        rAC, rCD	renamings indicated at each step
**		2,   1		path index at each step
**	     rAC o rCD		composition of renamings
**	Each proposition has already been renamed by its composite renaming.
**	In addition, if it is known to be redundant because it duplicates some
**	other proposition in one of the traits in its pedigree, it contains a
**	pointer to that other proposition.
**
**
**  MODIFICATION HISTORY:
**
**	{0} Garland  at MIT     -- 91.12.20 -- Original
**      {n} Who      at Where   -- yy.mm.dd -- What
**--
*/


/*
**
**  MACRO DEFINITIONS (none)
**
*/


/*
**
**  TYPEDEFS
**
*/

typedef traitNode	*traitPtr;
typedef renaming	*renamingPtr;

typedef struct {
    unsigned int 	 depth;		/* max index for lineage, etc. 	*/
    traitPtr		*lineage;	/* vector of ancestor traits	*/
    renamingPtr		*renamings;	/* renamings for ancestors 	*/
    unsigned int	*path;		/* sibling index for ancestors 	*/
    renaming		*rename;	/* composite of renamings	*/
} ancestry;

typedef enum {EQPROP, GENPROP, PARTPROP, TRAITPROP} propKind;

typedef struct {
    propKind		 kind;
    union {
	equationNode	*eqn;
	genByNode	*genBy;
	partByNode	*partBy;
	char		*dummy;				/* for TRAIT	*/
    } choice;
    ancestry		*pedigree;
    ancestry		*duplicate;			/* none if NIL	*/
    int			 key;				/* for hashing  */
} prop;



/*
**
**  FUNCTION PROTOTYPES
**
*/

extern ancestry		*ancestry_create (traitNode *t);
extern bool		 ancestry_equal (ancestry *a1, ancestry *a2);
extern ancestry		*ancestry_extend (ancestry *a, traitNode *t, 
					  renaming *r, unsigned int child);
extern unsigned int	 ancestry_length (ancestry *a);
# define		 ancestry_length(a) ((a)->depth)
extern traitNode	*ancestry_bottomTrait (ancestry *a);
extern traitNode	*ancestry_topTrait (ancestry *a);
extern void		 ancestry_unparse (ancestry *a, bool renamings);

extern propKind		 prop_kind (prop *p);
# define		 prop_kind(p) ((p)->kind)
extern int		 prop_key (prop *p);
# define		 prop_key(p) ((p)->key)
extern ancestry		*prop_pedigree (prop *p);
# define		 prop_pedigree(p) ((p)->pedigree)
extern ancestry		*prop_duplicate (prop *p);
# define		 prop_duplicate(p) ((p)->duplicate)
extern bool		 prop_isDuplicate (prop *p);
# define		 prop_isDuplicate(p) ((p)->duplicate != (ancestry *)0)
extern prop		*prop_makeTrait (ancestry *a);
extern equationNode	*prop_equation (prop *p);
# define		 prop_equation(p) ((p)->choice.eqn)
extern prop		*prop_makeEqn (equationNode *e, ancestry *a);
extern genByNode	*prop_genBy (prop *p);
# define		 prop_genBy(p) ((p)->choice.genBy)
extern prop		*prop_makeGenBy (genByNode *g, ancestry *a);
extern partByNode	*prop_partBy (prop *p);
# define		 prop_partBy(p) ((p)->choice.partBy)
extern prop		*prop_makePartBy (partByNode *p, ancestry *a);
extern prop		*prop_rename (prop *p, ancestry *a);
extern bool		 prop_similar (prop *p1, prop *p2);
extern bool		 prop_unchanged (prop *p1, prop *p2);


/*
**
**  EXTERNAL VARIABLES (none)
**
*/
