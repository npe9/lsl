/*
**
**	Copyright (c) MIT, 1990, 1991, 1992, 1993, 1994
**	All Rights Reserved.  Unpublished rights reserved under the copyright 
**	laws of the United States.
**
**++
**  FACILITY:  LSL Checker
**
**  MODULE DESCRIPTION:
**
**      FILENAME:   reduce.c
**
**	PURPOSE:    Larch Shared Language generator
**	
**	This module is responsible for processing the reduction actions
**	in the shift/reduce sequence generated by the parser.  It unstacks
**	all tokens shifted by the parser.
**
**	The actions are in a large switch -- one per rule.
**	The best use of the rules is to call semantic routines
**	(rather than putting the semantics inline).
**
**	
**  MODIFICATION HISTORY:
**
**      {0} McKeeman at Digital -- 90.03.06 -- Original
**	{1} Feldman  at Digital	-- 90.08.09 -- Change to latest 2.3 grammar
**	{2} Feldman  at Digital	-- 90.08.15 -- Add "Reducing " to Trace macro
**	{3} Wild     at Digital	-- 90.08.17 -- Include "string2sym.h" for init
**					       Pop Shifts as necessary.
**	{4} Garland  at MIT	-- 90.09.12 -- Tidy up, call semantic routines
**	{5} Garland  at MIT	-- 90.10.10 -- Unshift all tokens
**	{6} Wild     at Digital -- 90.11.09 -- Include osdfiles.h
**      {7} Garland  at MIT     -- 92.01.13 -- Allow eqSepSym at end of eqSeq,
**					       add locator for traitRef
**      {8} Garland  at MIT     -- 92.06.14 -- Composite sort notation A$B
**      {9} Garland  at MIT     -- 93.11.26 -- Recognize iff, priority
**     {10} Garland  at MIT     -- 94.04.20 -- Generated freely
**     {11} Garland  at MIT     -- 94.05.23 -- Composite sort notation A[B, C]
**     {12} Garland  at MIT     -- 94.05.27 -- Redo formal parameters
**      {n} Who      at Where   -- yy.mm.dd -- What
**--
*/


/*
**
**  INCLUDE FILES
**
*/

# include "general.h"
# include "osdfiles.h"
# include "string2sym.h"
# include "token.h"
# include "parse.h"
# include "shift.h"
# include "reduce.h"
# include "list.h"
# include "set.h"
# include "abstract.h"


/*
**
**  MACRO DEFINITIONS
**
*/

# if TRACING == 1
#    define Trace(rule) printf("Reducing: %s\n", rule)
# else
#    define Trace(rule)
# endif

# define PopShiftStack    	LSLGenPopShiftStack
# define TopShiftStack    	LSLGenTopShiftStack
# define TopPopShiftStack    	LSLGenTopPopShiftStack


/*
**
**  TYPEDEFS
**
*/

/*
**
**  FORWARD FUNCTIONS
**
*/

extern void		LSLGenReduce();


/*
**
**  STATIC VARIABLES
**
*/

/*
**
**  FUNCTION DEFINITIONS
**
*/


void
LSLGenReduce(LSLRuleCode rule) {
LSLToken tok;
switch (rule) {

			/* trait:	 				    */
case TRAIT1:		/*    traitId                   : TRAIT traitbody   */
    Trace("TRAIT1");
    LSLAbstractTrait(rule, TopPopShiftStack());			 /* `trait' */
    PopShiftStack();						 /* `:'     */
    break;

case TRAIT2:		/*    traitId formalparameters : trait traitbody    */
    Trace("TRAIT2");
    LSLAbstractTrait(rule, TopPopShiftStack());			 /* `trait' */
    PopShiftStack();						 /* `:'     */
    PopShiftStack();					         /* `)'     */
    PopShiftStack();					         /* `('     */
    break;

			/* formalList:					    */
case FORMALLIST1:	/*      formal					    */
    Trace("FORMALLIST1");
    LSLAbstractParameterList();
    break;

case FORMALLIST2:	/*      formalList , formal			    */
    Trace("FORMALLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractParameterListExtend();
    break;

			/* formal:					    */
case FORMAL1:		/*      name : signature			    */
    Trace("FORMAL1");
    LSLAbstractFormal(rule);
    break;

			/* formal:					    */
case FORMAL2:		/*      opForm					    */
    Trace("FORMAL2");
    LSLAbstractFormal(rule);
    break;

case FORMAL3:		/*	compoundSort				    */
    Trace("FORMAL3");
    LSLAbstractFormal(rule);
    break;

case FORMAL4:		/*	sortOrOpId				    */
    Trace("FORMAL4");
    LSLAbstractFormal(rule);
    break;

			/* name:					    */
case NAME1:		/*	simpleId				    */
    Trace("NAME1");
    LSLAbstractMakeLeaf(simpleId, TopPopShiftStack());		/* simpleId */
    LSLAbstractName(rule);
    break;

case NAME2:		/*	opForm					    */
    Trace("NAME2");
    /* LSLAbstractName already called by OPFORM routines */
    break;

			/* opForm:					    */
case OPFORM1:		/*	IF markerSym THEN markerSym ELSE markerSym  */
    Trace("OPFORM1");
    PopShiftStack();					  /* discard `__'   */
    PopShiftStack();					  /* discard `else' */
    PopShiftStack();					  /* discard `__'   */
    PopShiftStack();					  /* discard `then' */
    PopShiftStack();					  /* discard `__'   */
    LSLAbstractIfOp(TopPopShiftStack());		  /* `if'	    */
    break;

case OPFORM2:		/*	anyOp					    */
    Trace("OPFORM2");
    LSLAbstractPpiOp(rule, CommentToken);
    break;

case OPFORM3:		/*	markerSym anyOp				    */
    Trace("OPFORM3");
    LSLAbstractPpiOp(rule, TopPopShiftStack()); 		    /* `__' */
    break;

case OPFORM4:		/*	anyOp markerSym				    */
    Trace("OPFORM4");
    PopShiftStack();					    /* discard `__' */
    LSLAbstractPpiOp(rule, CommentToken);
    break;

case OPFORM5:		/*	markerSym anyOp markerSym		    */
    Trace("OPFORM5");
    PopShiftStack();					    /* discard `__' */
    LSLAbstractPpiOp(rule, TopPopShiftStack()); 	    /* `__'         */
    break;

case OPFORM6:		/*	openSym middle closeSym			    */
    Trace("OPFORM6");
    {LSLToken close, open;
     close = TopPopShiftStack();				/* closeSym */
     open = TopPopShiftStack();					/* openSym  */
     LSLAbstractMixfixOp(rule, open, close, open);
 }
    break;

case OPFORM7:		/*	markerSym openSym middle closeSym	    */
    Trace("OPFORM7");
    {LSLToken close, open;
     close = TopPopShiftStack();				/* closeSym */
     open = TopPopShiftStack();					/* openSym  */
     LSLAbstractMixfixOp(rule, open, close, TopPopShiftStack());/* `__'     */
 }
    break;

case OPFORM8:		/*	openSym middle closeSym markerSym	    */
    Trace("OPFORM8");
    PopShiftStack();					    /* discard `__' */
    {LSLToken close, open;
     close = TopPopShiftStack();				/* closeSym */
     open = TopPopShiftStack();					/* openSym  */
     LSLAbstractMixfixOp(rule, open, close, open);
 }
    break;

case OPFORM9:		/*	markerSym openSym middle closeSym markerSym */
    Trace("OPFORM9");
    PopShiftStack();					    /* discard `__' */
    {LSLToken close, open;
     close = TopPopShiftStack();				/* closeSym */
     open = TopPopShiftStack();					/* openSym  */
     LSLAbstractMixfixOp(rule, open, close, TopPopShiftStack());/* `__'     */
 }
    break;

case OPFORM10:		/*	selectSym simpleId			    */
    Trace("OPFORM10");
    {LSLToken op;
     op = TopPopShiftStack();				        /* simpleId */
    LSLAbstractSelectOp(rule, op, TopPopShiftStack());	        /* `.'      */
 }
    break;

case OPFORM11:		/*	markerSym selectSym simpleId		    */
    Trace("OPFORM11");
    {LSLToken op;
     op = TopPopShiftStack();				     /* simpleId    */
     PopShiftStack();					     /* discard `.' */
     LSLAbstractSelectOp(rule, op, TopPopShiftStack());	     /* `__'	    */
 }
    break;

			/* anyOp:					    */
case ANYOP1:		/*	simpleOp				    */
    Trace("ANYOP1");
    LSLAbstractAnyOp(rule, TopPopShiftStack());		        /* simpleOp */
    break;

case ANYOP2:		/*	logicalOp				    */
    Trace("ANYOP2");
    LSLAbstractAnyOp(rule, TopPopShiftStack());		       /* logicalOp */
    break;

case ANYOP3:		/*	eqOp					    */
    Trace("ANYOP3");
    LSLAbstractAnyOp(rule, TopPopShiftStack());		            /* eqOp */
    break;

			/* middle:					    */
case MIDDLE1:		/*						    */
    Trace("MIDDLE1");
    /* Disappears in abstract syntax */
    break;

case MIDDLE2:		/*      placeList				    */
    Trace("MIDDLE2");
    /* Disappears in abstract syntax */
    break;

			/* placeList:					    */
case PLACELIST1:	/*      markerSym				    */
    Trace("PLACELIST1");
    LSLAbstractSeparatorList();
    PopShiftStack();				            /* discard `__' */
    break;

case PLACELIST2:	/*      placeList separator markerSym		    */
    Trace("PLACELIST2");
    LSLAbstractSeparatorListExtend();
    PopShiftStack();				            /* discard `__' */
    break;

			/* separator:					    */
case SEPARATOR1:	/*	sepSym					    */
    Trace("SEPARATOR1");
    LSLAbstractSeparator(TopPopShiftStack());			  /* sepSym */
    break;

case SEPARATOR2:	/*	,					    */
    Trace("SEPARATOR2");
    LSLAbstractSeparator(TopPopShiftStack());			     /* `,' */
    break;


			/* signature:					    */
case SIGNATURE1:	/*	domain mapSym range		    	    */
    Trace("SIGNATURE1");
    LSLAbstractSignature(TopPopShiftStack());			    /* `->' */
    break;


			/* domain:					    */
case DOMAIN1:		/*						    */
    Trace("DOMAIN1");
    /* Disappears in abstract syntax */
    break;

case DOMAIN2:		/*	sortList				    */
    Trace("DOMAIN2");
    /* Disappears in abstract syntax */
    break;

			/* sortList:					    */
case SORTLIST1:		/*	sort					    */
    Trace("SORTLIST1");
    LSLAbstractSortList();
    break;

case SORTLIST2:		/*	sortList , sort				    */
    Trace("SORTLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractSortListExtend();
    break;

			/* range					    */
case RANGE1:		/*	sort					    */
    Trace("RANGE1");
    /* Disappears in abstract syntax */
    break;

			/* sort:					    */
case SORT1:		/*	sortId					    */
    Trace("SORT1");
    LSLAbstractSort(rule);
    break;

case SORT2:		/*	sort [ sortList ]			    */
    Trace("SORT2");
    PopShiftStack();				      /* discard ']'        */
    LSLAbstractSort(rule);
    PopShiftStack();				      /* discard '['        */
    break;

			/* traitBody:					    */
case TRAITBODY1:	/*      simpleTrait				    */
    Trace("TRAITBODY1");
    /* Disappears in abstract syntax */
    break;

case TRAITBODY2:	/*      simpleTrait consequences		    */
    Trace("TRAITBODY2");
    /* Disappears in abstract syntax */
    break;

case TRAITBODY3:	/*      traitContexts simpleTrait		    */
    Trace("TRAITBODY3");
    /* Disappears in abstract syntax */
    break;

case TRAITBODY4:	/*      traitContexts simpleTrait consequences	    */
    Trace("TRAITBODY4");
    /* Disappears in abstract syntax */
    break;

			/* traitContexts:				    */
case TRAITCONTEXTS1:	/*	traitContext				    */
    Trace("TRAITCONTEXTS1");
    LSLAbstractExtList();
    break;

case TRAITCONTEXTS2:	/*	traitContexts traitContext		    */
    Trace("TRAITCONTEXTS2");
    LSLAbstractExtListExtend();
    break;

			/* traitContext:				    */
case TRAITCONTEXT1:	/*      shorthand				    */
    Trace("TRAITCONTEXT1");
    /* Disappears in abstract syntax */
    break;

case TRAITCONTEXT2:	/*      external				    */
    Trace("TRAITCONTEXT2");
    /* Disappears in abstract syntax */
    break;

			/* shorthand:					    */
case SHORTHAND1:	/*      enumeration				    */
    Trace("SHORTHAND1");
    LSLAbstractExt(rule);
    break;

case SHORTHAND2:	/*      tuple					    */
    Trace("SHORTHAND2");
    LSLAbstractExt(rule);
    break;

case SHORTHAND3:	/*      union					    */
    Trace("SHORTHAND3");
    LSLAbstractExt(rule);
    break;

			/* enumeration:					    */
case ENUMERATION1:	/*      sort ENUMERATION OF elementIdList	    */
    Trace("ENUMERATION1");
    PopShiftStack();					   /* discard `of'  */
    LSLAbstractEnumeration(TopPopShiftStack());		   /* `enumeration' */
    break;

			/* elementIdList:				    */
case ELEMENTIDLIST1:	/*      elementId				    */
    Trace("ELEMENTIDLIST1");
    LSLAbstractElementIdList();
    break;

case ELEMENTIDLIST2:	/*      elementIdList , elementId		    */
    Trace("ELEMENTIDLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractElementIdListExtend();
    break;

			/* tuple:					    */
case TUPLE1:		/*      sort TUPLE OF fieldList			    */
    Trace("TUPLE1");
    PopShiftStack();					    /* discard `of' */
    LSLAbstractTuple(TopPopShiftStack());		    /* `tuple'      */
    break;

			/* union:					    */
case UNION1:		/*      sort UNION OF fieldList			    */
    Trace("UNION1");
    PopShiftStack();					    /* discard `of' */
    LSLAbstractUnion(TopPopShiftStack());  	           /* `union'      */
    break;

			/* fieldList:					    */
case FIELDLIST1:	/*      fields					    */
    Trace("FIELDLIST1");
    LSLAbstractFieldList();
    break;

case FIELDLIST2:	/*      fieldList , fields			    */
    Trace("FIELDLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractFieldListExtend();
    break;

			/* fields:					    */
case FIELDS1:		/*      fieldIdList : sort			    */
    Trace("FIELDS1");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractField();
    break;

			/* fieldIdList:					    */
case FIELDIDLIST1:	/*      fieldId					    */
    Trace("FIELDIDLIST1");
    LSLAbstractFieldIdList();
    break;

case FIELDIDLIST2:	/*      fieldIdList , fieldId			    */
    Trace("FIELDIDLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractFieldIdListExtend();
    break;

			/* external:					    */
case EXTERNAL1:		/*      INCLUDES traitRefList			    */
    Trace("EXTERNAL1");
    LSLAbstractIncludes(TopPopShiftStack());		      /* `includes' */
    LSLAbstractExt(rule);
    break;

case EXTERNAL2:		/*      ASSUMES traitRefList			    */
    Trace("EXTERNAL2");
    LSLAbstractAssumes(TopPopShiftStack());		      /* `assumes' */
    LSLAbstractExt(rule);
    break;

			/* traitRefList:				    */
case TRAITREFLIST1:	/*      traitRef				    */
    Trace("TRAITREFLIST1");
    LSLAbstractTraitRefList();
    break;

case TRAITREFLIST2:	/*      traitRefList , traitRef			    */
    Trace("TRAITREFLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractTraitRefListExtend();
    break;

			/* traitRef:					    */
case TRAITREF1:		/*      traitId					    */
    Trace("TRAITREF1");
    LSLAbstractTraitRef(rule, TopShiftStack());
    break;

case TRAITREF2:		/*      traitId ( renaming )			    */
    Trace("TRAITREF2");
    PopShiftStack();					     /* discard `)' */
    PopShiftStack();					     /* discard `(' */
    LSLAbstractTraitRef(rule, TopShiftStack());
    break;

case TRAITREF3:		/*      ( traitIdList )				    */
    Trace("TRAITREF3");
    PopShiftStack();					     /* discard `)' */
    tok = TopShiftStack();
    PopShiftStack();					     /* discard `(' */
    LSLAbstractTraitRef(rule, tok);
    break;

case TRAITREF4:		/*      ( traitIdList ) ( renaming )		    */
    Trace("TRAITREF4");
    PopShiftStack();					     /* discard `)' */
    PopShiftStack();					     /* discard `(' */
    PopShiftStack();					     /* discard `)' */
    tok = TopShiftStack();
    PopShiftStack();					     /* discard `(' */
    LSLAbstractTraitRef(rule, tok);
    break;

			/* traitIdList:					    */
case TRAITIDLIST1:	/*      traitId					    */
    Trace("TRAITIDLIST1");
    LSLAbstractTraitIdList();
    break;

case TRAITIDLIST2:	/*      traitIdList , traitId			    */
    Trace("TRAITIDLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractTraitIdListExtend();
    break;

			/* renaming:					    */
case RENAMING1:		/*	replaceList				    */
    Trace("RENAMING1");
    /* Disappears in abstract syntax */
    break;

case RENAMING2:		/*      actualList				    */
    Trace("RENAMING2");
    /* Disappears in abstract syntax */
    break;

case RENAMING3:		/*      actualList , replaceList		    */
    Trace("RENAMING3");
    PopShiftStack();					     /* discard `,' */
    /* Disappears in abstract syntax */
    break;

			/* actualList:					    */
case ACTUALLIST1:	/*      actual					    */
    Trace("ACTUALLIST1");
    LSLAbstractParameterList();
    break;

case ACTUALLIST2:	/*      actualList , actual			    */
    Trace("ACTUALLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractParameterListExtend();
    break;

			/* actual:					    */
case ACTUAL1:		/*      name				    */
    Trace("Actual1");
    LSLAbstractActual(rule);
    break;

case ACTUAL2:		/*	sort					    */
    Trace("Actual2");
    LSLAbstractActual(rule);
    break;

case ACTUAL3:		/*	sortOrOp				    */
    Trace("Actual3");
    LSLAbstractActual(rule);
    break;

			/* nameList:					    */
case NAMELIST1:		/*	name					    */
    Trace("NAMELIST1");
    LSLAbstractNameList();
    break;

case NAMELIST2:		/*	nameList , name				    */
    Trace("NAMELIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractNameListExtend();
    break;

			/* replaceList:					    */
case REPLACELIST1:	/*	replace					    */
    Trace("REPLACELIST1");
    LSLAbstractReplaceList();
    break;

case REPLACELIST2:	/*	replaceList , replace			    */
    Trace("REPLACELIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractReplaceListExtend();
    break;

			/* replace:					    */
case REPLACE1:		/*	actual FOR formal			    */
    Trace("REPLACE1");
    PopShiftStack();					   /* discard `for' */
    LSLAbstractReplace(rule);
    break;

			/* simpleTrait:					    */
case SIMPLETRAIT1:	/*      opParts propParts			    */
    Trace("SIMPLETRAIT1");
    /* Disappears in abstract syntax */
    break;

			/* opParts:					    */
case OPPARTS1:		/*						    */
    Trace("OPPARTS1");
    /* Disappears in abstract syntax */
    break;

case OPPARTS2:		/*      opParts INTRODUCES opDcls		    */
    Trace("OPPARTS2");
    LSLAbstractOpPart(TopPopShiftStack()); 		    /* `introduces' */
    break;

			/* opDcls:					    */
case OPDCLS1:		/*      opDcl					    */
    Trace("OPDCLS1");
    LSLAbstractOpDclList();
    break;

case OPDCLS2:		/*      opDcls opDcl				    */
    Trace("OPDCLS2");
    LSLAbstractOpDclListExtend();
    break;

			/* opDcl:					    */
case OPDCL1:		/*      NameList : signature			    */
    Trace("OPDCL1");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractOpDcl();
    break;

			/* propParts:					    */
case PROPPARTS1:	/*						    */
    Trace("PROPPARTS1");
    /* Disappears in abstract syntax */
    break;

case PROPPARTS2:	/*      propParts ASSERTS props			    */
    Trace("PROPPARTS2");
    LSLAbstractPropPart(TopPopShiftStack());		       /* `asserts' */
    break;

			/* props:					    */
case PROPS1:		/*						    */
    Trace("PROPS1");
    /* Disappears in abstract syntax */
    break;

case PROPS2:		/*      	     eqPart			    */
    Trace("PROPS2");
    /* Disappears in abstract syntax */
    break;

case PROPS3:		/*      genPartProps eqPart			    */
    Trace("PROPS3");
    /* Disappears in abstract syntax */
    break;

			/* genPartProps:				    */
case GENPARTPROPS1:	/*		     genPartProp		    */
    Trace("GENPARTPROPS1");
    LSLAbstractGenPartByList();
    break;

case GENPARTPROPS2:	/*      genPartProps genPartProp		    */
    Trace("GENPARTPROPS2");
    LSLAbstractGenPartByListExtend();
    break;

			/* genPartProp:					    */
case GENPARTPROP1:	/*	sort GENERATED BY operatorList		    */
    Trace("GENPARTPROP1");
    PopShiftStack();					    /* discard `by' */
    PopShiftStack();					    /* `freely'     */
    LSLAbstractGenBy(TopPopShiftStack(), TRUE);		    /* `generated'  */
    break;

case GENPARTPROP2:	/*	sort GENERATED BY operatorList		    */
    Trace("GENPARTPROP2");
    PopShiftStack();					    /* discard `by' */
    LSLAbstractGenBy(TopPopShiftStack(), FALSE);	    /* `generated'  */
    break;

case GENPARTPROP3:	/*	sort PARTITIONED BY operatorList	    */
    Trace("GENPARTPROP3");
    PopShiftStack();					   /* discard `by'  */
    LSLAbstractPartBy(TopPopShiftStack());		   /* `partitioned' */
    break;

			/* eqPart:					    */
case EQPART1:		/*      quantifiedEqSeqs			    */
    Trace("EQPART1");
    /* Disappears in abstract syntax */
    break;

case EQPART2:		/*      EQUATIONS eqSeq quantifiedEqSeqs	    */
    Trace("EQPART2");
    PopShiftStack();				     /* discard `equations' */
    /* Disappears in abstract syntax */
    break;

			/* operatorList:				    */
case OPERATORLIST1:	/*      operator				    */
    Trace("OPERATORLIST1");
    LSLAbstractOperatorList();
    break;

case OPERATORLIST2:	/*      operatorList , operator			    */
    Trace("OPERATORLIST2"); 
    PopShiftStack();					     /* discard `,' */
    LSLAbstractOperatorListExtend();
    break;

			/* operator					    */
case OPERATOR1:		/*	name					    */
    Trace("OPERATOR1");
    LSLAbstractOperator(rule);
    break;

case OPERATOR2:		/*	name : signature			    */
    Trace("OPERATOR2");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractOperator(rule);
    break;


			/* quantifiedEqSeqs:				    */
case QUANTIFIEDEQSEQS1:	/*						    */
    Trace("QUANTIFIEDEQSEQS1");
    /* Disappears in abstract syntax */
    break;

case QUANTIFIEDEQSEQS2:	/*      quantifiedEqSeqs quantifier eqSeq	    */
    Trace("QUANTIFIEDEQSEQS2");
    LSLAbstractQuantEqns();
    break;

    			/* eqSeq					    */
case EQSEQ1:		/*	eqSeqHead				    */
    Trace("EQSEQ1");
    break;

case EQSEQ2:		/*	eqSeqHead eqSepSym			    */
    Trace("EQSEQ2");
    PopShiftStack();					/* discard eqSepSym */
    break;


			/* eqSeqHead:					    */
case EQSEQHEAD1:	/*      equation				    */
    Trace("EQSEQHEAD1");
    LSLAbstractEquationList();
    break;

case EQSEQHEAD2:	/*      eqSeqHead eqSepSym equation		    */
    Trace("EQSEQHEAD2");
    PopShiftStack();					/* discard eqSepSym */
    LSLAbstractEquationListExtend();
    break;

			/* quantifier:					    */
case QUANTIFIER1:	/*      quantifierSym varDcl			    */
    Trace("QUANTIFIER1");
    PopShiftStack();				   /* discard quantifierSym */
    LSLAbstractVarDclList();
    break;

case QUANTIFIER2:	/*      quantifier , varDcl			    */
    Trace("QUANTIFIER2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractVarDclListExtend();
    break;

			/* varDcl:					    */
case VARDCL1:		/*      varIdList : sort			    */
    Trace("VARDCL1");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractVarDcl();
    break;

			/* varIdList:					    */
case VARIDLIST1:	/*      varId					    */
    Trace("VARIDLIST1");
    LSLAbstractVarIdList();
    break;

case VARIDLIST2:	/*      varIdList , varId			    */
    Trace("VARIDLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractVarIdListExtend();
    break;

			/* equation:					    */
case EQUATION1:		/*      term					    */
    Trace("EQUATION1");
    LSLAbstractEquation(rule);
    break;

case EQUATION2:		/*      term equationSym term			    */
    Trace("EQUATION2");
    PopShiftStack();					    /* discard `==' */
    LSLAbstractEquation(rule);
    break;

			/* term:					    */
case TERM1:		/*      logicalTerm				    */
    Trace("TERM1");
    /* Disappears in abstract syntax */
    break;


case TERM2:		/*      IF term THEN term ELSE term		    */
    Trace("TERM2");
    PopShiftStack();					  /* discard `else' */
    PopShiftStack();					  /* discard `then' */
    LSLAbstractTerm(rule, TopPopShiftStack());		  /* `if'	    */
    break;

			/* logicalTerm:					    */
case LOGICALTERM1:	/*	simpleOpTerm				    */
    Trace("LOGICALTERM1");
    /* Disappears in abstract syntax */
    break;

case LOGICALTERM2:	/*	logicalTerm logicalOp equalityTerm	    */
    Trace("LOGICALTERM2");
    LSLAbstractTerm(rule, TopPopShiftStack());		       /* logicalOp */
    break;

case LOGICALTERM3:	/*	logicalTerm eqOp equalityTerm		    */
    Trace("LOGICALTERM2");
    LSLAbstractTerm(rule, TopPopShiftStack());		       /* eqOp	    */
    break;

			/* simpleOpTerm:				    */
case SIMPLEOPTERM1:	/*	prefixOpTerm				    */
    Trace("SIMPLEOPTERM1");
    /* Disappears in abstract syntax */
    break;

case SIMPLEOPTERM2:	/*	secondary postfixOps			    */
    Trace("SIMPLEOPTERM2");
    /* Disappears in abstract syntax (handled by postfixOps) */
    break;

case SIMPLEOPTERM3:	/*	secondary infixOpPart			    */
    Trace("SIMPLEOPTERM3");
    /* Disappears in abstract syntax (handled by infixOpPart) */
    break;

			/* prefixOpTerm:				    */
case PREFIXOPTERM1:	/*      secondary				    */
    Trace("PREFIXOPTERM1");
    /* Disappears in abstract syntax */
    break;

case PREFIXOPTERM2:	/*      simpleOp prefixOpTerm			    */
    Trace("PREFIXOPTERM2");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

case PREFIXOPTERM3:	/*      quantifiedVar prefixOpTerm		    */
    Trace("PREFIXOPTERM3");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

    			/* quantifiedVar:				    */
case QUANTIFIEDVAR1:	/*	quantifierSym1 simpleId			    */
    Trace("QUANTIFIEDVAR1");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleId */
    break;
    
case QUANTIFIEDVAR2:	/*	quantifierSym1 simpleId	: sort		    */
    Trace("QUANTIFIEDVAR2");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleId */
    break;

			/* postfixOps:					    */
case POSTFIXOPS1:	/*      simpleOp				    */
    Trace("POSTFIXOPS1");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

case POSTFIXOPS2:	/*      postfixOps simpleOp			    */
    Trace("POSTFIXOPS2");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

			/* infixOpPart:					    */
case INFIXOPPART1:	/*      simpleOp secondary			    */
    Trace("INFIXOPPART1");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

case INFIXOPPART2:	/*      infixOpPart simpleOp secondary		    */
    Trace("INFIXOPPART2");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleOp */
    break;

			/* secondary:					    */
case SECONDARY1:	/*      primary					    */
    Trace("SECONDARY1");
    /* Disappears in abstract syntax */
    break;

case SECONDARY2:	/*      bracketed				    */
    Trace("SECONDARY2");
    /* Disappears in abstract syntax */
    break;

case SECONDARY3:	/*      bracketed primary			    */
    Trace("SECONDARY3");
    LSLAbstractTerm(rule, CommentToken);
    break;

case SECONDARY4:	/*      primary bracketed			    */
    Trace("SECONDARY4");
    LSLAbstractTerm(rule, CommentToken);
    break;

case SECONDARY5:	/*      primary bracketed primary		    */
    Trace("SECONDARY5");
    LSLAbstractTerm(rule, CommentToken);
    break;

			/* bracketed:					    */
case BRACKETED1:	/*      matched : sort				    */
    Trace("BRACKETED1");
    PopShiftStack();					     /* discard `:' */
    LSLAbstractTerm(rule, CommentToken);
    break;

case BRACKETED2:	/*      matched					    */
    Trace("BRACKETED2");
    /* Disappears in abstract syntax */
    break;

			/* matched:					    */
case MATCHED1:		/*      openSym args closeSym			    */
    Trace("MATCHED1");
    LSLAbstractMakeLeaf(closeSym, TopPopShiftStack());		/* closeSym */
    LSLAbstractTerm(rule, TopPopShiftStack());			/* openSym  */
    break;

case MATCHED2:		/*      openSym closeSym			    */
    Trace("MATCHED2");
    LSLAbstractMakeLeaf(closeSym, TopPopShiftStack());		/* closeSym */
    LSLAbstractTerm(rule, TopPopShiftStack());			/* openSym  */
    break;

			/* args:					    */
case ARGS1:		/*      term					    */
    Trace("ARGS1");
    LSLAbstractArgList();
    break;

case ARGS2:		/*      args separator term			    */
    Trace("ARGS2");
    LSLAbstractArgListExtend();
    break;

			/* primary:					    */
case PRIMARY1:		/*      ( term )				    */
    Trace("PRIMARY1");
    /* Disappears in abstract syntax */
    PopShiftStack();					     /* discard `)' */
    PopShiftStack();					     /* discard `(' */
    break;

case PRIMARY2:		/*      simpleId				    */
    Trace("PRIMARY2");
    LSLAbstractTerm(rule, TopPopShiftStack());			/* simpleId */
    break;

case PRIMARY3:		/*      simpleId ( termList )			    */
    Trace("PRIMARY3");
    PopShiftStack();					     /* discard `)' */
    PopShiftStack();					     /* discard `(' */
    LSLAbstractTerm(rule, TopPopShiftStack());		     /* simpleId    */
    break;

case PRIMARY4:		/*      primary selectSym simpleId		    */
    Trace("PRIMARY4");
    {LSLToken op;
     op = TopPopShiftStack();				       /* simpleId  */
     LSLAbstractSelectOp(OPFORM11, op, TopPopShiftStack());    /* selectSym */
 }
    LSLAbstractTerm(rule, CommentToken);
    break;

case PRIMARY5:		/*      primary : sort				    */
    Trace("PRIMARY5");
    PopShiftStack();				             /* discard `:' */
    LSLAbstractTerm(rule, CommentToken);
    break;

			/* termList:					    */
case TERMLIST1:		/*      term					    */
    Trace("TERMLIST1");
    LSLAbstractTermList();
    break;

case TERMLIST2:		/*      termList , term				    */
    Trace("TERMLIST2");
    PopShiftStack();					     /* discard `,' */
    LSLAbstractTermListExtend();
    break;

			/* consequences:				    */
case CONSEQUENCES1:	/*      IMPLIES conseqProps conversions		    */
    Trace("CONSEQUENCES1");
    LSLAbstractConsequences(TopPopShiftStack());	       /* `implies' */
    break;

			/* conseqProps:					    */
case CONSEQPROPS1:	/*			         eqPart		    */
    Trace("CONSEQPROPS1");
    /* Disappears in abstract syntax */
    break;

case CONSEQPROPS2:	/*	traitRefList		 eqPart		    */
    Trace("CONSEQPROPS2");
    /* Disappears in abstract syntax */
    break;

case CONSEQPROPS3:	/*		     genPartProps eqPart	    */
    Trace("CONSEQPROPS3");
    /* Disappears in abstract syntax */
    break;

case CONSEQPROPS4:	/*	traitRefList genPartProps eqPart	    */
    Trace("CONSEQPROPS4");
    /* Disappears in abstract syntax */
    break;

case CONSEQPROPS5:	/*		     genPartProps eqSeq		    */
    Trace("CONSEQPROPS5");
    /* Disappears in abstract syntax */
    break;

case CONSEQPROPS6:	/*	traitRefList genPartProps eqSeq		    */
    Trace("CONSEQPROPS6");
    /* Disappears in abstract syntax */
    break;

			/* conversions:					    */
case CONVERSIONS1:	/*						    */
    Trace("CONVERSIONS1");
    /* Disappears in abstract syntax */
    break;

case CONVERSIONS2:	/*      conversions conversion			    */
    Trace("CONVERSIONS2");
    /* Disappears in abstract syntax */
    break;

			/* conversion:					    */
case CONVERSION1:	/*      CONVERTS operatorList			    */
    Trace("CONVERSION1");
    LSLAbstractConversion(rule, TopPopShiftStack());	      /* `converts' */
    break;

case CONVERSION2:	/*      CONVERTS operatorList exemption		    */
    Trace("CONVERSION2");
    LSLAbstractConversion(rule, TopPopShiftStack());	      /* `converts' */
    break;

			/* exemption:					    */
case EXEMPTION1:	/*      EXEMPTING termList			    */
    Trace("EXEMPTION1"); 
    LSLAbstractExemption(rule, TopPopShiftStack());	       /* `exempts' */
    break;

case EXEMPTION2:	/*      EXEMPTING quantifier termList		    */
    Trace("EXEMPTION2");
    LSLAbstractExemption(rule, TopPopShiftStack());	       /* `exempts' */
    break;

			/* traitId:					    */
case TRAITID1:		/*      simpleId				    */
    Trace("TRAITID1");
    LSLAbstractMakeLeaf(traitId, TopPopShiftStack());		/* simpleId */
    break;

			/* sortId:					    */
case SORTID1:		/*	simpleId				    */
    Trace("SORTID1");
    LSLAbstractMakeLeaf(sortId, TopPopShiftStack());		/* simpleId */
    break;

			/* varId:					    */
case VARID1:		/*      simpleId				    */
    Trace("VARID1");
    LSLAbstractMakeLeaf(varId, TopPopShiftStack());		/* simpleId */
    break;

			/* fieldId:					    */
case FIELDID1:		/*      simpleId				    */
    Trace("FIELDID1");
    LSLAbstractMakeLeaf(fieldId, TopPopShiftStack());		/* simpleId */
    break;

			/* elementId:					    */
case ELEMENTID1:	/*      simpleId				    */
    Trace("ELEMENTID1");
    LSLAbstractMakeLeaf(elementId, TopPopShiftStack());		/* simpleId */
    break;

			/* sortOrOpId:					    */
case SORTOROPID1:	/*      simpleId				    */
    Trace("SORTOROPID1");
    LSLAbstractMakeLeaf(simpleId, TopPopShiftStack());		/* simpleId */
    break;

}							/* end switch	    */
}							/* end Reduce()	    */
